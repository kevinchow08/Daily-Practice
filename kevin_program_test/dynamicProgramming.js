// 从“爬楼梯”问题说起

// > 题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
// 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

// 思路分析与编码实现

// 这道题目有两个关键的特征：
// 1. 要求你给出达成某个目的的**解法个数**
// 2. 不要求你给出每一种解法对应的具体路径

// 这样的问题，往往可以用动态规划进行求解。

// 在这道题里，“问题的终点”指的就是走到第 n 阶楼梯这个目标对应的路径数，我们把它记为 f(n)
// 那么站在第 n 阶楼梯这个视角， 有哪些后退的可能性呢？按照题目中的要求，一次只能后退 1 步或者 2 步。因此可以定位到从第 n 阶楼梯只能后退到第 n-1 或者第 n-2 阶。
// 我们把抵达第 n-1 阶楼梯对应的路径数记为f(n-1)，把抵达第 n-2 阶楼梯对应的路径数记为 f(n-2)，不难得出以下关系：
// f(n) = f(n-1) + f(n-2)

// 一：故，向前递推，到f(1), f(2),可得：

function climbStairs(n) {
    if (n === 1 || n === 2) {
        return n
    }
    return climbStairs(n - 1) + climbStairs(n - 2)
}

// 二：但是这个解法问题比较大,重复计算带来了时间效率上的问题，要想解决这类问题.
// 最直接的思路就是用空间换时间，也就是想办法记住之前已经求解过的结果

const arr = []
function climbStairs(n) {
    if (arr[n]) {
        return arr[n]
    }
    // 将本次n计算得结果缓存起来，放进arr数组中，当下次访问得时候，就可以率先返回值
    arr[n] = (n === 1 || n === 2) ?  n :  climbStairs(n - 1) + climbStairs(n - 2)
    return arr[n]
}
// 以上这种在递归的过程中，不断保存已经计算出的结果，从而避免重复计算的手法，叫做 记忆化搜索

// 三：记忆化搜索转化为动态规划
// 要想完成记忆化搜索与动态规划之间的转化，首先要清楚两者间的区别：

// 先说 记忆化搜索，记忆化搜索可以理解为优化过后的递归。递归往往可以基于树形思维模型来做
// 我们基于树形思维模型来解题时，实际上是站在了一个比较大的未知数量级（也就是最终的那个 n ），来不断进行拆分，最终拆回较小的已知数量级（f(1)、f(2)）
// 这个过程是一个明显的自顶向下的过程。

// 动态规划则恰恰相反，是一个 自底向上 的过程。
// 它要求我们站在已知的角度，通过定位已知和未知之间的关系，一步一步向前推导，进而求解出未知的值
// 在这道题中，以 f(1) 和 f(2) 为起点，不断求和，循环递增 n 的值，我们就能够求出 f(n) 了：
function climbStairs(n) {
    const arr = []
    // 初始化已知值
    arr[1] = 1
    arr[2] = 2
    // 循环遍历出arr[3]到arr[n]的结果
    // 要得到arr[n],也要从arr[3]开始算起
    for (let i = 3; i <= n; i++) {
        arr[i] = arr[i - 1] + arr[i - 2]
    }
    return arr[n]
}


// 总结一下，对于动态规划，笔者建议大家优先选择这样的分析路径：

// 1. 递归思想明确树形思维模型：找到问题终点，思考倒退的姿势，往往可以帮助你更快速地明确 状态间的关系
// 2. 结合记忆化搜索，明确 状态转移方程
// 3. 递归代码转化为迭代表达（这一步不一定是必要的，1、2本身为思维路径，而并非代码实现。若你成长为熟手，2中分析出来的状态转移方程可以直接往循环里塞，根本不需要转换）
